---
title: "photometa"
output: html_document
date: "2023-08-28"
---

## Creates a .csv table 'ecotaxa_sfer-mbon.txt' containing image file names, cruise data for the corresponding stations, and deep feature fields generated with Jan's python script modified by Pieter.

## Install packages and load libraries
```{r, echo=FALSE}
# install.packages("magick")
library(magick)
library(tidyverse)
library(lubridate)
library(dplyr)
library(data.table)
library(hrbrthemes)
library(magrittr)
```

## Load taxa lists and metadata table
```{r, echo=FALSE}
# specify the directory where the files are located
dir_path <- "~/Library/CloudStorage/GoogleDrive-enriquemontes01@gmail.com/My Drive/GDrive/OCED_AOML/WS_cruises/plankton_imaging/CPICS/TS.Master_selection"

# obtain a list of file names in the directory
file_names <- list.files(path = dir_path, pattern = ".txt", full.names = TRUE)

# loop over each file and import the tables (use this for DATES)
for (file in file_names) {
  table_name <- gsub(".txt", "", basename(file)) # get the name of the table from the file name
  assign(table_name, read.table(file = file, header = FALSE, sep = "\t") %>%
           mutate(date = as.POSIXct(substr(V1, start = 24, stop = 38), format="%Y%m%d_%H%M%S", tz="UTC")))
}
```

## Load deep feature table generated by the python code
```{r}
# Set the file path
file_path <- "/Users/enrique.montes/Desktop/ellipse_data_selected_unclassified.csv"

# Load the data into a data frame
ellipse_data_selected_unclassified <- read.csv(file_path)

# Display the first few rows of the data frame to confirm it's loaded correctly
head(ellipse_data_selected_unclassified)

```

## Match images to cruise data with all taxa lists
```{r, echo=FALSE}
# Directory where the CTD metadata is located
dir_path2 <- "/Users/enrique.montes/Library/CloudStorage/GoogleDrive-enriquemontes01@gmail.com/My Drive/GDrive/OCED_AOML/WS_cruises/plankton_imaging/CPICS/ws_cruise_ctd"

# or use this path
# dir_path2 <- dir_path <- "~/Library/CloudStorage/GoogleDrive-enriquemontes01@gmail.com/My Drive/GDrive/OCED_AOML/WS_cruises/plankton_imaging/CPICS/ws_cruise_ctd"

file_name <- list.files(path = dir_path2, pattern = "ctd_meta_v4.csv", full.names = TRUE)
# # Use with ctd_meta_v2.csv:
# ctd_meta <- read.csv(file_name, fill = TRUE) %>%
#   mutate(GMT.datetime = as.POSIXct(GMT.datetime, format="%Y%m%d_%H%M", tz="UTC"))
# # Use with ctd_meta_v3.csv:
ctd_meta <- read.csv(file_name, fill = TRUE) %>%
  mutate(GMT.datetime = as.POSIXct(paste(year, month, day, time_gmt), 
                                   format="%Y %m %d %I:%M:%S %p", tz="UTC"))


# List of data frame names
data_frame_names <- ls(pattern = "^class\\.")

# Initialize an empty list to store results
result_list <- list()

# Iterate over each data frame
for (df_name in data_frame_names) {
  # Get the data frame using the name
  current_df <- get(df_name)
  
  # Rename columns if needed
  current_df <- current_df %>% rename(datetime = date, img_file_name = V1)
  
  # Extract the species ID from data_frame_name
  object_speciesID <- sub("^class\\.", "", df_name)
  
  # Iterate over each row in the data frame
  for (i in seq_len(nrow(current_df))) {
    
    # Check if datetime is within range (MAKE SURE THE DATE IS LAST DAY OF LAST MONTH SAMPLED)
    if (current_df$datetime[i] <= as.POSIXct("2024-11-30 23:59:59", tz = "UTC")) {
      
    # Find the index of the closest datetime in ctd_meta
    closest_index <- which.min(abs(ctd_meta$GMT.datetime - current_df$datetime[i]))
    
    # Extract corresponding data from ctd_meta
    result <- data.table(
      img_file_name = substr(current_df$img_file_name[i], start = 24, stop = 48),
      object_id = substr(current_df$img_file_name[i], start = 24, stop = 44),
      object_speciesID = object_speciesID,  # Use the extracted object_speciesID
      object_date = gsub("-", "", as.Date(current_df$datetime[i])),
      object_time = format(current_df$datetime[i], format = "%H%M%S"),
      cruiseID = ctd_meta$cruiseID[closest_index],
      ctd_date = gsub("-", "", as.Date(ctd_meta$GMT.datetime[closest_index])),
      ctd_time = format(ctd_meta$GMT.datetime[closest_index], format = "%H%M%S"),
      station = ctd_meta$Station[closest_index],
      object_lat = ctd_meta$dec_lat[closest_index],
      object_lon = ctd_meta$dec_lon[closest_index],
      object_depth_min = 0,
      object_depth_max = ctd_meta$depth_max[closest_index],
      temp_degC = ctd_meta$temp..degC.[closest_index],
      salinity = ctd_meta$salinity[closest_index],
      chl_a = ctd_meta$Avg.chl.a..ug.L.[closest_index],
      do = ctd_meta$DO..mg.L.[closest_index],
      nitrate = ctd_meta$NO3....uM.[closest_index],
      phosphate = ctd_meta$PO4...uM.[closest_index],
      silicate = ctd_meta$Si.....uM.[closest_index],
      seascape.8day = ctd_meta$X8.day.seascapes[closest_index],
      seascape.monthly = ctd_meta$monthly.seascapes[closest_index]
    )
    
    # Append the result to the result list
    result_list[[length(result_list) + 1]] <- result
    }
  }
}

# Combine all results into a single data table
final_table_all <- rbindlist(result_list)

# write.table(final_table_all,"~/Desktop/final_table_all.txt",sep="\t",row.names=FALSE)

# Extract unique filenames from both data frames
filenames_in_ellipse = unique(ellipse_data_selected_unclassified$filename)
filenames_in_final_table = unique(final_table_all$img_file_name)

# Find filenames present in ellipse_data_selected_unclassified but not in final_table_all
missing_filenames = setdiff(filenames_in_ellipse, filenames_in_final_table)

# Print or return the list of missing filenames
missing_filenames

```

## Merge roi IDs, cruise data, and roi metadata 
```{r, echo=FALSE}
source(here::here("lib/sources.R"))

# Extract object IDs from final_table_all
object_ids <- final_table_all$img_file_name

# Extract corresponding imageFile IDs from ellipse_data_selected_unclassified
imageFile_ids <- basename(ellipse_data_selected_unclassified$filename)

# Find matching indices
matching_indices <- match(object_ids, imageFile_ids)

# Create a new data frame by combining metadata values with final_table_all
combined_table <- cbind(final_table_all, ellipse_data_selected_unclassified[matching_indices, ])

# correct values in ecotaxa_table (eg min depth)
combined_table$object_depth_min = 1

# Add additional fields
acquisition_instrument = "CPICS"
process_pixel = "4.54"
acquisition_author = "Enrique Montes (NOAA AOML)"
acquisition_id = "export_23642_20241122_1524_sfer" # as export_#images_yyyymmdd_hhmm_sfer

# Add new columns 'acq_author' and 'acq_instrument' to the data frame
combined_table$acq_author <- rep(acquisition_author, nrow(combined_table))
combined_table$acq_instrument <- rep(acquisition_instrument, nrow(combined_table))
combined_table$acq_id <- rep(acquisition_id, nrow(combined_table))

#Correction for pixel size (converts pixels from CPICS to um)
combined_table %>%
  mutate(
    object_major = object_major  *  as.numeric(process_pixel),
    object_minor = object_minor *  as.numeric(process_pixel),
    object_area = object_area   *   (as.numeric(process_pixel)^2),
    object_width = object_width  *  as.numeric(process_pixel),
    object_height = object_height  *  as.numeric(process_pixel),
    object_perimeter = object_perimeter  *  as.numeric(process_pixel)
  ) -> combined_table

# Count the number of rows in final_table_all that don't match imageFile_ids objects
num_non_matching <- sum(is.na(matching_indices))
print(num_non_matching)

# Export table
# - add data format codes; [f] for floats, [t] for text
format_codes <- as.data.frame(matrix(c("[t]", "[t]", "[t]", "[t]", "[t]", "[t]", "[t]", "[t]", "[t]", "[t]", "[t]", "[f]", "[f]", "[f]", "[f]", "[f]", "[f]", "[f]", "[f]", "[f]", "[t]", "[t]", "[t]", "[f]", "[f]", "[f]", "[f]", "[f]", "[f]", "[f]", "[f]", "[f]", "[f]", "[f]", "[f]", "[f]", "[t]", "[t]", "[t]"), nrow = 1))
colnames(format_codes) <- colnames(combined_table)
selected_columns <- c(1,2,4,5,10:13,24:39)
ecotaxa_table <- rbind(format_codes[, selected_columns], select(combined_table, 
                                                                img_file_name, 
                                                                object_id, 
                                                                object_date,
                                                                object_time,
                                                                object_lat,
                                                                object_lon,
                                                                object_depth_min,
                                                                object_depth_max,
                                                                object_major,
                                                                object_minor,
                                                                object_area,
                                                                object_circularity,
                                                                object_perimeter,
                                                                object_width,
                                                                object_height,
                                                                object_sharpness,
                                                                object_saturation,
                                                                object_redness,
                                                                object_greeness,
                                                                object_blueness,
                                                                object_colorfulness,
                                                                acq_instrument,
                                                                acq_author,
                                                                acq_id))

# DO NOT WRITE CSV TABLE becasue turns date and time strings into floating objects
# write.table(ecotaxa_table,"~/Desktop/ecotaxa_sfer_mbon.txt",sep="\t",row.names=FALSE)
# Write the ecotaxa_table to a TSV file on the desktop
write.table(ecotaxa_table, "~/Desktop/ecotaxa_sfer-mbon.tsv", sep = "\t", row.names = FALSE, quote = FALSE)

```

# Check if all files listed in 'ecotaxa_table' are present in the 'selected' directory
```{r, echo=FALSE}
# Directory path where files should be present
selected_directory <- "~/Desktop/selected/"

# Get a list of file names from the data frame
file_names_in_df <- final_table_all$img_file_name

# List all files in the 'selected' directory
files_in_directory <- list.files(selected_directory)

# Check for missing files
missing_files <- setdiff(file_names_in_df, files_in_directory)

if (length(missing_files) == 0) {
  cat("All files listed in the data frame are present in the directory.\n")
} else {
  cat("Missing files:\n")
  cat(paste(missing_files, collapse = "\n"), "\n")
}

# Check for duplicated file names in df$file_names
duplicated_files <- ecotaxa_table[duplicated(ecotaxa_table$img_file_name), "img_file_name"]

if (length(duplicated_files) == 0) {
  cat("No duplicated file names found in the 'file_names' column.\n")
} else {
  cat("Duplicated file names:\n")
  cat(paste(duplicated_files, collapse = "\n"), "\n")
}

```

# Use this to subset the ecotaxa_table by species (object_speciesID)
```{r, echo=FALSE}
# Extract the first row of ecotaxa_table as the header row
header_row <- ecotaxa_table[1, ]

# Extract all unique object_speciesID from final_table_all
unique_species <- unique(final_table_all$object_speciesID)

# Initialize a list to store data frames
species_data_frames <- list()

# Loop through each unique species
for (species in unique_species) {
  # Find indices where object_speciesID matches the current species
  species_indices <- which(final_table_all$object_speciesID == species)
  
  # Subset ecotaxa_table using these indices, skipping the first row
  subset_data <- ecotaxa_table[(species_indices + 1), ]

  # Prepend the header_row to the subset
  species_data_frames[[species]] <- rbind(header_row, subset_data)
}

# Write each subset to a TSV file
for (species in names(species_data_frames)) {
  write.table(species_data_frames[[species]], 
              paste0("ecotaxa_", species, "_sfer-mbon.tsv"), 
              sep = "\t", 
              row.names = FALSE, 
              quote = FALSE)
}

```
